// ABOUTME: Data model for native ProofMode library proof metadata
// ABOUTME: Stores cryptographic proof data from Guardian Project libProofMode

/// Native ProofMode proof data from libProofMode library
///
/// Generated by native Android/iOS ProofMode libraries after video recording.
/// Simpler than ProofManifest - doesn't track recording sessions/segments,
/// just provides cryptographic proof for the final video file.
class NativeProofData {
  const NativeProofData({
    required this.videoHash,
    this.sensorDataCsv,
    this.pgpSignature,
    this.publicKey,
    this.deviceAttestation,
    this.timestamp,
    this.c2paManifestId,
  });

  /// Create from JSON
  factory NativeProofData.fromJson(Map<String, dynamic> json) =>
      NativeProofData(
        videoHash: json['videoHash'] as String,
        sensorDataCsv: json['sensorDataCsv'] as String?,
        pgpSignature: json['pgpSignature'] as String?,
        publicKey: json['publicKey'] as String?,
        deviceAttestation: json['deviceAttestation'] as String?,
        timestamp: json['timestamp'] as String?,
        c2paManifestId: json['c2paManifestId'] as String?,
      );

  /// Create from raw proof metadata map (from NativeProofModeService)
  factory NativeProofData.fromMetadata(Map<String, String> metadata) =>
      NativeProofData(
        videoHash: metadata['hash']!,
        sensorDataCsv: metadata['csv'],
        pgpSignature: metadata['signature'],
        publicKey: metadata['publicKey'],
        c2paManifestId: metadata['c2pa_manifest_id'],
        deviceAttestation: metadata['deviceAttestation'],
      );

  /// SHA256 hash of the video file (used as proof identifier)
  final String videoHash;

  /// CSV sensor data (location, network, device info, etc.)
  final String? sensorDataCsv;

  /// OpenPGP signature of the video file
  final String? pgpSignature;

  /// PGP public key used for signing
  final String? publicKey;

  /// Device attestation token (Google SafetyNet on Android)
  final String? deviceAttestation;

  /// Timestamp of proof generation
  final String? timestamp;

  /// C2PA manifest data
  final String? c2paManifestId;

  /// Convert to JSON for storage
  Map<String, dynamic> toJson() => {
    'videoHash': videoHash,
    if (sensorDataCsv != null) 'sensorDataCsv': sensorDataCsv,
    if (pgpSignature != null) 'pgpSignature': pgpSignature,
    if (publicKey != null) 'publicKey': publicKey,
    if (deviceAttestation != null) 'deviceAttestation': deviceAttestation,
    if (timestamp != null) 'timestamp': timestamp,
    if (c2paManifestId != null) 'c2paManifestId': c2paManifestId,
  };

  /// Check if proof data is complete
  bool get isComplete =>
      pgpSignature != null && publicKey != null && sensorDataCsv != null;

  /// Check if this is a mobile proof with device attestation
  bool get hasMobileAttestation =>
      deviceAttestation != null || c2paManifestId != null;

  /// Get verification level for Nostr tags
  String get verificationLevel {
    if (hasMobileAttestation && pgpSignature != null) {
      return 'verified_mobile';
    }
    if (pgpSignature != null) {
      return 'verified_web';
    }
    if (sensorDataCsv != null) {
      return 'basic_proof';
    }
    return 'unverified';
  }

  /// Get PGP fingerprint from public key (simplified)
  String? get pgpFingerprint {
    if (publicKey == null) return null;
    // TODO(any): Extract actual fingerprint from PGP public key.
    // For now, return first 40 chars of key as placeholder
    return publicKey!.length > 40 ? publicKey!.substring(0, 40) : publicKey;
  }

  @override
  String toString() =>
      'NativeProofData(hash: $videoHash, '
      'hasSignature: ${pgpSignature != null}, '
      'hasAttestation: ${deviceAttestation != null})';
}
